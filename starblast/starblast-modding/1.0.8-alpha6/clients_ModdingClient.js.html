<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Source: clients/ModdingClient.js - starblast-modding</title>
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="../styles/dark.css">
    <link type="text/css" rel="stylesheet" href="../styles/default.css">
</head>
<body>

    <nav class="sidebar">
        <header class="nav-header">
            <a href="index.html">
                <img class="nav-logo" src="images/logo.svg" src="image" onerror="this.onerror=null; this.src='images/logo.png'"/>
                <h1>starblast-modding</h1>
            </a>
        </header>

        <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Alien.html">Alien</a></li><li><a href="AlienManager.html">AlienManager</a></li><li><a href="ArrayMap.html">ArrayMap</a></li><li><a href="Asteroid.html">Asteroid</a></li><li><a href="AsteroidManager.html">AsteroidManager</a></li><li><a href="Collectible.html">Collectible</a></li><li><a href="CollectibleManager.html">CollectibleManager</a></li><li><a href="Coordinate.html">Coordinate</a></li><li><a href="Entity.html">Entity</a></li><li><a href="EntityManager.html">EntityManager</a></li><li><a href="ModdingClient.html">ModdingClient</a></li><li><a href="Object3D.html">Object3D</a></li><li><a href="ObjectManager.html">ObjectManager</a></li><li><a href="ObjectType.html">ObjectType</a></li><li><a href="ObjectTypeManager.html">ObjectTypeManager</a></li><li><a href="Ship.html">Ship</a></li><li><a href="ShipManager.html">ShipManager</a></li><li><a href="Station.html">Station</a></li><li><a href="StationManager.html">StationManager</a></li><li><a href="StationModule.html">StationModule</a></li><li><a href="StationModuleManager.html">StationModuleManager</a></li><li><a href="Structure.html">Structure</a></li><li><a href="StructureManager.html">StructureManager</a></li><li><a href="Team.html">Team</a></li><li><a href="TeamManager.html">TeamManager</a></li></ul>
    </nav>

    <div id="main">
        <h1 class="page-title">Source: clients/ModdingClient.js</h1>

        



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const EventEmitter = require("events");
const defineProperties = require("../utils/defineProperties.js");
const toString = require("../utils/toString.js");
const StructureManager = require("../managers/StructureManager.js");
const managers = [
  { path: ["ships"] },
  { path: ["asteroids"] },
  { path: ["aliens"] },
  { path: ["collectibles"] },
  { path: ["objects"] },
  { path: ["objects", "types"] },
  { path: ["teams"], },
  { path: ["teams", "stations"] },
  { path: ["teams", "stations"], mapper: v => v.modules }
];

/**
 * The Modding Client Instance.
 * @extends {EventEmitter}
 * @param {object} options - options for calling the object, currently has the following properties:&lt;br>&lt;ul>&lt;li>&lt;b>&lt;code>cacheConfiguration&lt;/code>&lt;/b> - set to &lt;code>true&lt;/code> if you want to reuse data (ECP Key, regions, etc.) for the next run, &lt;code>false&lt;/code> otherwise&lt;/li>&lt;/ul>
 */

class ModdingClient extends EventEmitter {

  constructor (options) {
    super();
    var modding = {};
    defineProperties(modding, {
      api: new (require("../rest/ModdingAPI.js"))(this, options),
      gameClient: new (require("./GameClient.js"))(this),
      events: require("../resources/Events.js"),
      handlers: defineProperties({}, {
        create: new Map(),
        destroy: new Map()
      }),
      create_requests: [],
      data: {}
    });
    defineProperties(this, {modding});
    this.reset(true)
  }

  #gameClient;

  /**
   * Indicates if the game is started or not.
   * @type {boolean}
   * @readonly
   */

  get started () {
    return !!this.modding.api.started
  }

  /**
   * Indicates if the game is stopped or not.
   * @type {boolean}
   * @readonly
   */

  get stopped () {
    return !!this.modding.api.stopped
  }

  /**
   * Trigger the &lt;code>onError&lt;/code> event.
   * @param {string} message - Error message
   * @returns {boolean}
   */

  error (message) {
    return this.emit('error', new Error(message), this)
  }

  /**
   * Trigger the &lt;code>onLog&lt;/code> event.
   * @param {string} messages - Log messages strings
   * @returns {boolean}
   */

  log (...data) {
    return this.emit(this.modding.events.LOG, ...data)
  }

  /**
   * Set the region of the client.
   * @param {string} regionName - region name, must be either Asia, America or Europe
   * @returns {ModdingClient}
   */

  setRegion (region) {
    if (this.started) return this.error("Could not set region while the mod is running");
    this.modding.api.configuration.region = region;
    return this
  }

  /**
   * Set the options for the modded game
   * @param {options} options - game options, same as &lt;code>this.options&lt;/code> uses in browser modding
   * @returns {ModdingClient}
   */

  setOptions (options) {
    if (this.started) return this.error("Could not set options while the mod is running");
    this.modding.api.configuration.options = options;
    return this
  }

  /**
   * Set the ECP key that client will use for requests
   * @param {string} ECPKey - The ECP key
   * @returns {ModdingClient}
   */

  setECPKey (ECPKey) {
    if (this.started) return this.error("Could not set ECPKey while the mod is running");
    this.modding.api.configuration.ECPKey = ECPKey;
    return this
  }

  /**
   * Configure the client
   * @param {object} options - An object with the following properties:&lt;br>&lt;ul>&lt;li>&lt;b>&lt;code>options&lt;/code>&lt;/b> - Modded game options&lt;/li>&lt;li>&lt;b>&lt;code>region&lt;/code>&lt;/b> - Modded game region&lt;/li>&lt;li>&lt;b>&lt;code>ECPKey&lt;/code>&lt;/b> - ECP key&lt;/li>&lt;/ul>
   * @returns {ModdingClient}
   */

  configure (options) {
    if (this.started) return this.error("Could not configure while the mod is running");
    if (options?.hasOwnProperty?.('region')) this.setRegion(options.region);
    if (options?.hasOwnProperty?.('options')) this.setOptions(options.options);
    if (options?.hasOwnProperty?.('ECPKey')) this.setECPKey(options.ECPKey);
    return this
  }

  /**
   * Set the game state to "open"(true) (still attracts new players) or "closed"(false) (not attract new players)
   * @param {boolean} isOpen - &lt;code>true&lt;/code> to keep the game open, &lt;code>false&lt;/code> otherwise.
   * @returns {ModdingClient}
   */

  setOpen (value) {
    this.modding.api.name("set_open").prop("value", value).send();
    return this
  }

  /**
   * Set the custom map for the game
   * @param {string} mapPattern - The map pattern
   * @returns {ModdingClient}
   */

  setCustomMap (map) {
    this.modding.api.name("set_custom_map").data(map).send();
    return this
  }

  /**
   * Find a structrue based on its UUID
   * @param {string} uuid - An UUID (Universal Unique Identifier) to search for
   * @returns {Structure} - The structure object, &lt;code>null&lt;/code> if not found any.
   */

  findStructureByUUID (uuid, includeInactive = false) {
    Search: for (let keys of managers) {
      let manager = this;
      for (let key of keys.path) {
        manager = manager[key];
        if (manager == null) continue Search
      }
      if (!(manager instanceof StructureManager)) continue Search;
      if (includeInactive) manager = manager.all;
      if ("function" == typeof keys.mapper) manager = manager.map(keys.mapper);
      let results = manager.flat(Infinity).find(structure => Object.is(structure.uuid, uuid));
      if (results != null) return results
    }

    return null
  }

  /**
   * Starts the game
   * @param {object} options - Options Object, same as calling configure(options)
   * @returns {Promise&lt;string>} Link of the game
   */

  async start (options) {
    if (this.started) throw new Error("Mod already started");
    return await this.configure(options).modding.api.start()
  }

  /**
   * Stops the game
   * @returns {Promise&lt;ModdingClient>}
   */

  async stop () {
    if (this.stopped) throw new Error("Mod already stopped");
    return await this.modding.api.stop()
  }

  /**
   * The ship manager of the game
   * @type {ShipManager}
   * @readonly
   */

  get ships () {
    return this.modding.data.ships.update()
  }

  /**
   * The alien manager of the game
   * @type {AlienManager}
   * @readonly
   */

  get aliens () {
    return this.modding.data.aliens.update()
  }

  /**
   * The asteroid manager of the game
   * @type {AsteroidManager}
   * @readonly
   */

  get asteroids () {
    return this.modding.data.asteroids.update()
  }

  /**
   * The collectible manager of the game
   * @type {CollectibleManager}
   * @readonly
   */

  get collectibles () {
    return this.modding.data.collectibles.update()
  }

  /**
   * The object manager of the game
   * @type {ObjectManager}
   * @readonly
   */

  get objects () {
    return this.modding.data.objects.update()
  }

  /**
   * The team manager of the game. Coule be &lt;code>null&lt;/code> if the modded game is not team-based.
   * @type {TeamManager}
   * @readonly
   */

  get teams () {
    return this.modding.data.teams?.update?.() ?? null
  }

  /**
   * The game options object
   * @type {object}
   * @readonly
   */

  get options () {
    return this.modding.data.options
  }

  /**
   * The game step
   * @type {number}
   * @readonly
   */

  get step () {
    return this.modding.data.step
  }

  /**
   * The game link
   * @type {string}
   * @readonly
   */

  get link () {
    let api = this.modding.api;
    return (api.started &amp;&amp; !api.stopped) ? "https://starblast.io/#" + api.id + "@" + api.ip + ":" + api.port : null
  }

  reset (init) {

    /**
     * Custom object served for assigning data by the user
     * @type {object}
     */

    this.custom = {};
    let stopError = new Error("Mod had stopped before the action could be completed");
    for (let key of ["create", "destroy"]) {
      let handlers = [...this.modding.handlers[key].entries()];
      this.modding.handlers[key].clear();
      for (let handler of handlers) handler[1]?.reject?.(stopError)
    }
    this.modding.create_requests.splice(0);
    Object.assign(this.modding.data, {
      aliens: new (require("../managers/AlienManager.js"))(this),
      asteroids: new (require("../managers/AsteroidManager.js"))(this),
      collectibles: new (require("../managers/CollectibleManager.js"))(this),
      ships: new (require("../managers/ShipManager.js"))(this),
      objects: new (require("../managers/ObjectManager.js"))(this),
      teams: null,
      options: null,
      step: -1
    });
    if (!init) this.modding.api.reset()
  }
}

module.exports = ModdingClient
</code></pre>
        </article>
    </section>




    </div>

    <br class="clear">

    <footer>
        Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a>
    </footer>
    <script> prettyPrint(); </script>
    <script src="scripts/linenumber.js"> </script>
    <script type="text/javascript" src="../scripts/default.js"></script>
</body>
</html>
